# Create additional configuration files to complete the setup

# Create .dockerignore file
dockerignore = """# Dependencies
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Production
.next
out
build
dist

# Environment variables
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
*.log

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE
.vscode
.idea

# Git
.git
.gitignore

# Documentation
README.md
docs/

# Development files
docker-compose.yml
.dockerignore
"""

# Create .gitignore file
gitignore = """# Dependencies
node_modules
/.pnp
.pnp.js

# Testing
/coverage

# Production
.next/
out/
build/
dist/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Dependency directories
node_modules/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next

# Nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# IDE
.vscode
.idea
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Database
*.db
*.sqlite
*.sqlite3

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock
"""

# Create next.config.js for proper Next.js configuration
next_config = """/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  poweredByHeader: false,
  compress: true,
  
  // Environment variables that should be available on the client side
  env: {
    CUSTOM_KEY: process.env.CUSTOM_KEY,
  },

  // Headers for security
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-Content-Type-Options', 
            value: 'nosniff'
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin'
          }
        ]
      }
    ]
  },

  // Redirects for better SEO
  async redirects() {
    return []
  },

  // Webpack configuration
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    return config
  },

  // Experimental features
  experimental: {
    serverComponentsExternalPackages: []
  }
}

module.exports = nextConfig
"""

# Create basic health check endpoints
health_endpoint = """// app/health/route.js
// Health check endpoint for the main application

export async function GET() {
  try {
    // Basic health checks
    const checks = {
      timestamp: new Date().toISOString(),
      status: 'healthy',
      version: process.env.npm_package_version || '1.0.0',
      environment: process.env.NODE_ENV || 'development'
    }

    // Check database connection if available
    if (process.env.DATABASE_URL) {
      // Add database health check here
      checks.database = 'connected'
    }

    return new Response(JSON.stringify(checks), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache, no-store, must-revalidate'
      }
    })
  } catch (error) {
    return new Response(JSON.stringify({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json'
      }
    })
  }
}
"""

# Create migration script
migration_script = """#!/bin/bash

# Database migration script for Sim Studio
# This script handles database setup and migrations

set -e

echo "üóÑÔ∏è Sim Studio Database Migration"
echo "================================="

# Check if DATABASE_URL is set
if [ -z "$DATABASE_URL" ]; then
    echo "‚ùå DATABASE_URL environment variable is not set"
    exit 1
fi

echo "‚úÖ DATABASE_URL is configured"

# Install dependencies if needed
if [ ! -d "node_modules" ]; then
    echo "üì¶ Installing dependencies..."
    if [ -f "yarn.lock" ]; then
        yarn install
    elif [ -f "package-lock.json" ]; then
        npm ci
    else
        npm install
    fi
fi

# Run database migrations
echo "üîÑ Running database migrations..."

# Check if we're using Drizzle (Sim Studio's ORM)
if [ -f "apps/sim/drizzle.config.ts" ]; then
    cd apps/sim
    echo "Running Drizzle migrations..."
    npx drizzle-kit push
    cd ../..
else
    echo "‚ö†Ô∏è No Drizzle configuration found, skipping migrations"
fi

# Seed database if needed
echo "üå± Seeding database (if needed)..."

# Add any seed data commands here
# For example:
# npx tsx scripts/seed.ts

echo "‚úÖ Database migration completed successfully!"
"""

# Create monitoring and logging configuration
logging_config = """// lib/logger.js
// Centralized logging configuration for Sim Studio

const isDevelopment = process.env.NODE_ENV === 'development'
const logLevel = process.env.LOG_LEVEL || (isDevelopment ? 'debug' : 'info')

class Logger {
  constructor() {
    this.levels = {
      error: 0,
      warn: 1, 
      info: 2,
      debug: 3
    }
    this.currentLevel = this.levels[logLevel] || this.levels.info
  }

  formatMessage(level, message, meta = {}) {
    const timestamp = new Date().toISOString()
    const logEntry = {
      timestamp,
      level,
      message,
      ...meta
    }
    
    if (isDevelopment) {
      return `[${timestamp}] ${level.toUpperCase()}: ${message}`
    }
    
    return JSON.stringify(logEntry)
  }

  log(level, message, meta = {}) {
    if (this.levels[level] <= this.currentLevel) {
      console.log(this.formatMessage(level, message, meta))
    }
  }

  error(message, meta = {}) {
    this.log('error', message, meta)
  }

  warn(message, meta = {}) {
    this.log('warn', message, meta)
  }

  info(message, meta = {}) {
    this.log('info', message, meta)
  }

  debug(message, meta = {}) {
    this.log('debug', message, meta)
  }
}

export const logger = new Logger()
export default logger
"""

# Save all additional files
additional_files = {
    '.dockerignore': dockerignore.strip(),
    '.gitignore': gitignore.strip(),
    'next.config.js': next_config.strip(),
    'app/health/route.js': health_endpoint.strip(),
    'migrate.sh': migration_script.strip(),
    'lib/logger.js': logging_config.strip()
}

import os

# Create directories if they don't exist
os.makedirs('app/health', exist_ok=True)
os.makedirs('lib', exist_ok=True)

# Create and save each additional file
for filename, content in additional_files.items():
    with open(filename, 'w') as f:
        f.write(content)
    print(f"‚úÖ Created {filename}")

# Make migration script executable
os.chmod('migrate.sh', 0o755)

print(f"\nüéâ Successfully created {len(additional_files)} additional configuration files!")
print("\nAdditional files created:")
for filename in additional_files.keys():
    print(f"  - {filename}")

print("\nüìÅ Directory structure:")
print("  ‚îú‚îÄ‚îÄ render.yaml (Render Blueprint)")
print("  ‚îú‚îÄ‚îÄ Dockerfile (Main app)")  
print("  ‚îú‚îÄ‚îÄ Dockerfile.realtime (Realtime server)")
print("  ‚îú‚îÄ‚îÄ package.json (Dependencies)")
print("  ‚îú‚îÄ‚îÄ next.config.js (Next.js config)")
print("  ‚îú‚îÄ‚îÄ docker-compose.yml (Local development)")
print("  ‚îú‚îÄ‚îÄ .env.example (Environment template)")
print("  ‚îú‚îÄ‚îÄ README.md (Documentation)")
print("  ‚îú‚îÄ‚îÄ deploy.sh (Deployment helper)")
print("  ‚îú‚îÄ‚îÄ health-check.sh (Health monitoring)")
print("  ‚îú‚îÄ‚îÄ migrate.sh (Database migrations)")
print("  ‚îú‚îÄ‚îÄ .dockerignore (Docker ignore rules)")
print("  ‚îú‚îÄ‚îÄ .gitignore (Git ignore rules)")
print("  ‚îú‚îÄ‚îÄ app/")
print("  ‚îÇ   ‚îî‚îÄ‚îÄ health/")
print("  ‚îÇ       ‚îî‚îÄ‚îÄ route.js (Health endpoint)")
print("  ‚îî‚îÄ‚îÄ lib/")
print("      ‚îî‚îÄ‚îÄ logger.js (Logging utility)")